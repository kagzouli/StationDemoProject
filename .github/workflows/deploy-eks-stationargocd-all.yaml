name: "[AWS] Deploy EKS station ArgoCD"

#on: [push]
on: 
  workflow_dispatch:
    inputs:
      environment:
        type: choice
        description: The environment to create
        options:
          - dev
        required: true

      region:
        type: choice
        description: The region where we can create objects
        options:
          - eu-west-3
        required: true

      supervision:
        type: choice
        description: Supervision (Oui/Non)
        default: non
        options:
          - non
          - oui
        required: true

      deployMode:
        type: choice
        description: Deploy mode (internal, external)
        default: internal
        options:
          - internal
       #  - external
        required: true

env:
  KUBERNETES_VERSION: v1.23.6
  ARGOCD_SERVER: "argocd.exakaconsulting.org:443"


jobs:
  # Deploy networks
  networks:
    uses: ./.github/workflows/terraform-networks-reusable.yaml
    with:
      # environment: ${{ env.ENVIRONMENT_NAME}}
      environment: ${{ github.event.inputs.environment}}
      region: ${{ github.event.inputs.region}}
    secrets:
      aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
      aws_secret_key:  ${{ secrets.AWS_SECRET_ACCESS_KEY }}

  # Deploy networks
  secrets:
    uses: ./.github/workflows/terraform-secrets-reusable.yaml
    needs: networks
    with:
      # environment: ${{ env.ENVIRONMENT_NAME}}
      environment: ${{ github.event.inputs.environment}}
      region: ${{ github.event.inputs.region}}
    secrets:
      aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
      aws_secret_key:  ${{ secrets.AWS_SECRET_ACCESS_KEY }}

  # Deploy EKS
  eks:
    uses: ./.github/workflows/terraform-eks-reusable.yaml
    needs: secrets
    with:
      # environment: ${{ env.ENVIRONMENT_NAME}}
      environment: ${{ github.event.inputs.environment}}
      region: ${{ github.event.inputs.region}}
    secrets:
      aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
      aws_secret_key:  ${{ secrets.AWS_SECRET_ACCESS_KEY }}


  # Deploy cloudwatchalarm if supervision is activated.
  cloudwatchalarm:
    uses: ./.github/workflows/terraform-cloudwatchalarm-reusable.yaml
    needs: eks
    if: ${{ github.event.inputs.supervision == 'oui' }}
    with:
      environment: ${{ github.event.inputs.environment}}
      region: ${{ github.event.inputs.region}}
    secrets:
      aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
      aws_secret_key:  ${{ secrets.AWS_SECRET_ACCESS_KEY }}  


  # Installation ArgoCD
  install_argocd:
    runs-on: ubuntu-latest
    needs: eks
    steps:
      
      - name: Checkout
        id: checkout
        uses: actions/checkout@v2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ github.event.inputs.region}}
          role-duration-seconds: 3600
          mask-aws-account-id: false
      
      - name: Installation Kubernetes
        id: kubernetes_installation
        run: curl -LO https://storage.googleapis.com/kubernetes-release/release/${{ env.KUBERNETES_VERSION }}/bin/linux/amd64/kubectl && chmod +x kubectl && mv kubectl /usr/local/bin/kubectl

      - name: Install Helm
        run: |
          curl -fsSLo get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3
          chmod 700 get_helm.sh
          ./get_helm.sh


      - name: Connect EKS cluster
        id: connect_eks_cluster
        run: aws eks --region ${{ github.event.inputs.region}} update-kubeconfig --name station-eks-cluster

      - name: Installation argoCD Namespace
        id: argocd-createnamespace
        run: kubectl get namespace | grep -q "^argocd" || kubectl create namespace argocd


      - name: Retrieve VPC CIDR
        id: argocd-vpc
        run: |
          echo "::set-output name=id::$( aws ec2 describe-vpcs --filter Name=tag:Name,Values=station_vpc --query 'Vpcs[].VpcId' --output text)"
          echo "::set-output name=cidr::$( aws ec2 describe-vpcs --filter Name=tag:Name,Values=station_vpc --query 'Vpcs[].CidrBlock' --output text )"
     

      - name: Installation argoCD
        id: argocd-installation
        run: kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml


      - name: Change NodePort ArgoCD Server
        id: argocd-nodeport
        run: bash changenoport-argocd.sh
        working-directory: kubernetes/argocd
      

  # Configuration ArgoCD
  install_shared_argocd:
    runs-on: ubuntu-latest
    needs: install_argocd
    steps:
      
      - name: Checkout
        id: checkout
        uses: actions/checkout@v2


      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ github.event.inputs.region}}
          role-duration-seconds: 3600
          mask-aws-account-id: false
      
      - name: Connect EKS cluster
        id: connect_eks_cluster
        run: aws eks --region ${{ github.event.inputs.region}} update-kubeconfig --name station-eks-cluster


      - name: Install Helm
        run: |
          curl -fsSLo get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3
          chmod 700 get_helm.sh
          ./get_helm.sh

      # Recuperer account
      - name: Retrieve account 
        id: retrieve-account
        run: echo "::set-output name=identifier::$( aws sts get-caller-identity --query 'Account' --output text )"

      - name: Retrieve VPC
        id: argocd-vpc
        run: |
          echo "::set-output name=id::$( aws ec2 describe-vpcs --filter Name=tag:Name,Values=station_vpc --query 'Vpcs[].VpcId' --output text)"
    

      # Installation composant transverse
      - name: Installation shared on argocd
        id:  argocd-installationshared
        run: |
          helm upgrade -i shared ./shared \
          --set app.accountidentifier="${{ steps.retrieve-account.outputs.identifier }}" \
          --set app.region="${{ github.event.inputs.region}}" \
          --set app.vpcId="${{ steps.argocd-vpc.outputs.id }}" 
        working-directory: kubernetes/argocd
   
      # Check that ALB load balancer controller is in state Running, Failed 
      - name: Waiting ALB load balancer to be running
        id:  albloadbalancercontroller-isrunnin
        run: |
          NOTPENDING_ALB_CONTROLLER=$( kubectl get pods -n transverse -o json  | jq -r '.items[] |  select( (.metadata.name |  contains("aws-load-balancer-controller")) and (.status.phase=="Running" or .status.phase=="Failed"))' | jq -jr '.metadata | .name, ", " ')
          while [[ -z "${NOTPENDING_ALB_CONTROLLER}" ]]
          do
            echo "Les pods ${NOTPENDING_ALB_CONTROLLER} de l'ALB load balancer controller sont encore en cours"
            sleep 5s
            NOTPENDING_ALB_CONTROLLER=$( kubectl get pods -n transverse -o json  | jq -r '.items[] |  select( (.metadata.name |  contains("aws-load-balancer-controller")) and (.status.phase=="Running" or .status.phase=="Failed"))' | jq -jr '.metadata | .name, ", " ')
          done

  # Configuration ArgoCD
  configuration_argocd:
    runs-on: ubuntu-latest
    needs: install_shared_argocd
    steps:
      
      - name: Checkout
        id: checkout
        uses: actions/checkout@v2

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ github.event.inputs.region}}
          role-duration-seconds: 3600
          mask-aws-account-id: false
      
      - name: Connect EKS cluster
        id: connect_eks_cluster
        run: aws eks --region ${{ github.event.inputs.region}} update-kubeconfig --name station-eks-cluster


      - name: Installation Kubernetes
        id: kubernetes_installation
        run: curl -LO https://storage.googleapis.com/kubernetes-release/release/${{ env.KUBERNETES_VERSION }}/bin/linux/amd64/kubectl && chmod +x kubectl && mv kubectl /usr/local/bin/kubectl



      - name: Installation argocdcli
        id:  argocd-installation
        run: sudo curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64 && sudo chmod +x /usr/local/bin/argocd


      - name: Install Helm
        run: |
          curl -fsSLo get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3
          chmod 700 get_helm.sh
          ./get_helm.sh

      - name: Retrieve targetGroupBinding
        id: argocd-targetgroupbinding
        run: |
          echo "::set-output name=targetGroupBinding::$( aws elbv2 describe-target-groups --name argocd-target-group  --query 'TargetGroups[0].TargetGroupArn' --output text)"


      - name: Retrieve VPC CIDR
        id: argocd-vpc
        run: |
          echo "::set-output name=cidr::$( aws ec2 describe-vpcs --filter Name=tag:Name,Values=station_vpc --query 'Vpcs[].CidrBlock' --output text )"


      - name: Open UI Argocd
        id: argocd-openui
        run: helm upgrade -i argocdinstall ./argocd --set argocd.ingress.targetGroupARN="${{ steps.argocd-targetgroupbinding.outputs.targetGroupBinding }}" --set argocd.network.vpc_cidr="${{ steps.argocd-vpc.outputs.cidr }}"
        working-directory: kubernetes/helm


      - name: Retrieve argocdpass
        id: argocd-pass
        run: |
          echo "::set-output name=password::$( aws secretsmanager get-secret-value --secret-id stationsec-secretmanager --query SecretString --output text |jq -r .argocdpassword |base64)"

      # Not working
      #- name: Change argocd password argocd-initsecret
      #  id: argocd-change-initpassword
      #  run: |
      #    kubectl -n argocd patch secret argocd-initial-admin-secret \
      #    -p '{"stringData": {
      #    "password": "${{ steps.argocd-pass.outputs.password }}"
      #    }}'

     


  # Installation application ArgoCD
  install_application_argocd:
    runs-on: ubuntu-latest
    needs: configuration_argocd
    steps:
      
      - name: Checkout
        id: checkout
        uses: actions/checkout@v2



      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ github.event.inputs.region}}
          role-duration-seconds: 3600
          mask-aws-account-id: false
      
      - name: Connect EKS cluster
        id: connect_eks_cluster
        run: aws eks --region ${{ github.event.inputs.region}} update-kubeconfig --name station-eks-cluster


      - name: Install Helm
        run: |
          curl -fsSLo get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3
          chmod 700 get_helm.sh
          ./get_helm.sh

      # Recuperer stationback - TargetGroupBinding
      - name: Retrieve back ingress
        id: stationback-targetgroupbinding
        run: |
          echo "::set-output name=targetGroupBinding::$( aws elbv2 describe-target-groups --name station-back-target-group  --query 'TargetGroups[0].TargetGroupArn' --output text)"

      # Recuperer stationback - ALB list
      - name: Retrieve back albiplist temp
        id: stationback-albiplisttemp
        run: |
          echo "::set-output name=albiplist::$( aws ec2 describe-network-interfaces --filters "Name=description,Values=ELB app/station-back-alb/$(aws elbv2 describe-load-balancers --names station-back-alb | grep -wE 'LoadBalancerArn' | xargs | cut -d / -f 4 | cut -d , -f 1)" --query 'NetworkInterfaces[*].PrivateIpAddresses[*].PrivateIpAddress' --output text | xargs | sed 's/ /,/g'  )"

      - name: Retrieve back albiplist
        id: stationback-albiplist
        run: |
          echo "::set-output name=albiplist::$( echo {"${{ steps.stationback-albiplisttemp.outputs.albiplist }}"} )"
  

      # Recuperer stationfront - TargetGroupBinding
      - name: Retrieve front ingress 
        id: stationfront-targetgroupbinding
        run: |
          echo "::set-output name=targetGroupBinding::$( aws elbv2 describe-target-groups --name station-front-target-group  --query 'TargetGroups[0].TargetGroupArn' --output text)"

      # Recuperer stationfront - ALB list
      - name: Retrieve front albiplist temp
        id: stationfront-albiplisttemp
        run: |
          echo "::set-output name=albiplist::$(  aws ec2 describe-network-interfaces --filters "Name=description,Values=ELB app/station-front-alb/$(aws elbv2 describe-load-balancers --names station-front-alb | grep -wE 'LoadBalancerArn' | xargs | cut -d / -f 4 | cut -d , -f 1)" --query 'NetworkInterfaces[*].PrivateIpAddresses[*].PrivateIpAddress' --output text | xargs | sed 's/ /,/g' )"

      - name: Retrieve front albiplist
        id: stationfront-albiplist
        run: |
          echo "::set-output name=albiplist::$( echo {"${{ steps.stationfront-albiplisttemp.outputs.albiplist }}"}  )"



      # Recuperer redis mode
      - name: Retrieve redis mode
        id: stationredis-mode
        run: |
          if [[ "${{ github.event.inputs.deployMode }}" == "internal" ]]; then
                echo "::set-output name=mode::internalredis"
                echo "::set-output name=usessl::false"
          fi
          if [[ "${{ github.event.inputs.deployMode }}" == "external" ]]; then
              echo "::set-output name=mode::externalredis"
              echo "::set-output name=usessl::true"
          fi

      # Recuperer db - mode
      - name: Retrieve db mode
        id: stationdb-mode
        run: |
          if [[ "${{ github.event.inputs.deployMode }}" == "internal" ]]; then
                echo "::set-output name=mode::internaldb"
          fi
          if [[ "${{ github.event.inputs.deployMode }}" == "external" ]]; then
              echo "::set-output name=mode::externaldb"
          fi
      
      
      # Installation composant applications
      - name: Installation application on argocd
        id:  argocd-installationappli
        run: |
          helm upgrade -i applications ./applications \
          --set station.back.ingressarn="${{ steps.stationback-targetgroupbinding.outputs.targetGroupBinding }}" \
          --set station.back.albiplist="${{ steps.stationback-albiplist.outputs.albiplist }}" \
          --set station.front.ingressarn="${{ steps.stationfront-targetgroupbinding.outputs.targetGroupBinding }}" \
          --set station.front.albiplist="${{ steps.stationfront-albiplist.outputs.albiplist }}" \
          --set station.redis.mode="${{ steps.stationredis-mode.outputs.mode }}" \
          --set station.redis.usessl="${{ steps.stationredis-mode.outputs.usessl }}" \
          --set station.db.mode="${{ steps.stationdb-mode.outputs.mode }}" 
        working-directory: kubernetes/argocd
  

  # Synchronize application
  synchronize_application_argocd:
    runs-on: ubuntu-latest
    needs: install_application_argocd
    steps:

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ github.event.inputs.region}}
          role-duration-seconds: 3600
          mask-aws-account-id: false
      
      # Connect EKS cluster
      - name: Connect EKS cluster
        id: connect_eks_cluster
        run: aws eks --region ${{ github.event.inputs.region}} update-kubeconfig --name station-eks-cluster

      # Install cli
      - name: Install argocdcli
        id: install-argocdcli
        run: sudo curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64 && sudo chmod +x /usr/local/bin/argocd

      # Get password
      - name: Retrieve ArgoCD password
        id: retrieve-password-argocd
        run: |
          echo "::set-output name=value::$( kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)"

      # Login ArgoCD
      - name: login ArgoCD
        id: login-argocd
        run: argocd login ${{ env.ARGOCD_SERVER }}  --username admin --password ${{ steps.retrieve-password-argocd.outputs.value }} --insecure

      # Synchronize applications
      - name: Synchronize Applications
        id: synchronize-applications
        run: argocd app sync --prune --retry-limit 2 -l exakaconsulting/strategy=refresh



